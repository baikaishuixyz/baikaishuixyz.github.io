[{"title":"vue-cli目录结构以及配置说明","date":"2017-02-23T02:06:04.000Z","path":"2017/02/23/vue-cli-structure/","text":"本篇文章是根据原文翻译所得有疑问请参考原文，或联系我 1. vue-cli使用步骤$ npm install -g vue-cli $ vue init webpack my-project $ cd my-project $ npm install $ npm run dev 2. 项目结构. ├── build/ # webpack config files │ └── ... ├── config/ │ ├── index.js # main project config │ └── ... ├── src/ │ ├── main.js # app entry file │ ├── App.vue # main app component │ ├── components/ # ui components │ │ └── ... │ └── assets/ # module assets (processed by webpack) │ └── ... ├── static/ # pure static assets (directly copied) ├── test/ │ └── unit/ # unit tests │ │ ├── specs/ # test spec files │ │ ├── index.js # test build entry file │ │ └── karma.conf.js # test runner config file │ └── e2e/ # e2e tests │ │ ├── specs/ # test spec files │ │ ├── custom-assertions/ # custom assertions for e2e tests │ │ ├── runner.js # test runner script │ │ └── nightwatch.conf.js # test runner config file ├── .babelrc # babel config ├── .editorconfig # editor config ├── .eslintrc.js # eslint config ├── index.html # index.html template └── package.json # build scripts and dependencies build/这个目录是开发环境和webpack生产环境的配置目录。一般情况下不用修改这个文件夹中的文件，除非你想自定义你的webpack loaders，loaders的修改在build/webpack.base.conf.js中。 config/index.js这是项目build时的主要配置文件，它导出了最公用的配置项。进行个性化配置时可以参考API Proxying During Development和Integrating with Backend Framework src/这是开发项目的主要目录，你撸的代码绝大部分都在这个目录下，而在这个文件夹下如何构建你的目录结构则取决您的远见和需求；如果你使用了Vuex，你可以参阅recommendations for Vuex applications来构造响应目录。 static/如果您有一些静态文件，不希望被webpack处理，就可以放到这个目录下。/src下/assets目录下的静态文件会被webpack处理，build时这两个文件夹中的文件会被放倒同一个文件夹下，而/static下的文件会直接复制过去。 test/unit包含单元测试相关的文件，参考Unit Testing test/e2e包含e2e测试相关的文件，参考End-to-end Testing index.html这是我们要开发的单页面应用的首页模版。在开发和生产时，webpack打包生成的资源文件会自动插入到该模版中，并最终渲染出来。 package.jsonNPM的配置文件，包括build时的依赖和命令 3. 项目的build命令npm run build 4. Eslint配置默认使用Eslint的标准模式 如果你想自定义检测规则，可以修改.eslintrc.js 可以选择其他的检测模式 其他的详细配置，可以参考 ESLint documentation 5. 预处理器这个样板工程支持最流行的css预处理技术，包括LESS, SASS, Stylus, PostCss。你只要安装对应的webpack loader就可以使用以上预处理技术。以SASS为例： npm install sass-loader node-sass --save-dev 注意node-sass也要安装，因为sass-loader依赖它 在组件内部使用预处理安装完成后，你可以在.vue文件中使用预处理技术，使用方法实在&lt;style&gt;标签中添加lang字段: &lt;style lang=&quot;scss&quot;&gt; /* write SASS! */ &lt;/style&gt; * lang=&quot;scss&quot; corresponds to the CSS-superset syntax (with curly braces and semicolones). * lang=&quot;sass&quot; corresponds to the indentation-based syntax. 6. 后处理器在.vue文件中的css部分默认都会经过PostCss处理, 你不用为此下载特殊的loader。你只需要简单的在build/webpack.base.conf.js中的vue部分添加要使用的PostCss插件即可。 // build/webpack.base.conf.js module.exports = { // ... vue: { postcss: [/* your plugins */] } } 详细请参考：vue-loader’s related documentation 7. 独立的CSS文件为了坚持一贯的组件化和预处理，建议在App.vue中导入全局的独立样式文件，例如： &lt;!-- App.vue --&gt; &lt;style src=&quot;./styles/global.less&quot; lang=&quot;less&quot;&gt;&lt;/style&gt; 注意： 导入的独立样式文件是你自己为该单页面应用所编写的，如果是一些库的样式文件，你可以放在/static文件夹中，然后在index.html中直接引用 。这避免了额外的build时间，也有利于浏览器的缓存（参考：Static Asset Handling） 8. 静态资源的处理你已经看到了，在项目中有两个和静态资源相关的文件夹：src/assets和static/, 它们之间有什么不同呢？ webpack 处理的静态资源： /src/assets为了回答上述问题，首先要明白webpack怎么处理静态资源。在*.vue文件中，template和css都会被vue-html-loader和css-loader处理，它们会查找静态资源的URL。比如，在&lt;img src=&#39;./logo.png&#39;、background: url(./logo.png),其中的./logo.png都是相对路径，这些会被webpack作为模块依赖进行处理。 因为logo.png不是 JavaScript,作为一个依赖来对待，就需要url-loader和file-loader来处理，样板工程已经帮你配置好了，处理后的文件会带有签名，以及在限制大小后转化成base64，所以你可以使用相对路径而不用担心部署的问题。 由于在build过程中assets中的资源可能被处理成base64、被复制、重命名，它们本质上是源代码的一部分。这就是问什么建议将需要webpack处理的资源放到src下，而把不需要处理的放到其他目录。实际上，静态文件不必须放到/src/assets目录下，你可以根据module/component来组织相应的静态文件。比如你可以为每一个组件和他的静态文件建立一个文件夹， Asset 处理规则 相对路径： 比如./assets/logo.png 将作为模块依赖被处理，它们将会被webpack输出配置自动生成的的URL替换。 没有前缀的路径和相对路径一样： assets/logo.png会转换成 ./aseets/logo.png 使用~前缀：~ are treated as a module request, similar to require(&#39;some-module/image.png&#39;). You need to use this prefix if you want to leverage Webpack’s module resolving configurations. For example if you have a resolve alias for assets, you need to use &lt;img src=&quot;~assets/logo.png&quot;&gt; to ensure that alias is respected. 绝对路径：/assets/logo.png不会被处理 使用JavaScript获得资源路径为了使webpack能返回一个正确的资源路径，你需要使用require(&#39;./relative/path/to/file.jpg&#39;) ，这样会被file-loader处理，然后返回一个处理后的URL。例如： computed: { background () { return require(&apos;./bgs/&apos; + this.id + &apos;.jpg&apos;) } } “真正”的静态文件作为比较，static/目录下的文件都不会被webpack处理，它们会被原封不动的复制到最终的目录。所以必须使用绝对路径引用它们，这些有配置文件config.js中的bulid.assetsPublicPath和build.assetsSubDirectory联合决定。 下面是默认配置： // config.js module.exports = { // ... build: { assetsPublicPath: &apos;/&apos;, assetsSubDirectory: &apos;static&apos; } } 所有放在static/目录下的文件应该使用绝对路径/static/[filename]。如果你将assetSubDirectory改成assets,那绝对路径的url也需要改变为/assets/[filename] 更详细的配置请参考backend integration 9. 环境变量有时开发的应用要运行于不同的环境下，这就需要配置环境变量。 例子： // config/prod.env.js module.exports = { NODE_ENV: &apos;&quot;production&quot;&apos;, DEBUG_MODE: false, API_KEY: &apos;&quot;...&quot;&apos; // this is shared between all environments } // config/dev.env.js module.exports = merge(prodEnv, { NODE_ENV: &apos;&quot;development&quot;&apos;, DEBUG_MODE: true // this overrides the DEBUG_MODE value of prod.env }) // config/test.env.js module.exports = merge(devEnv, { NODE_ENV: &apos;&quot;testing&quot;&apos; }) 注意： 字符串变量需要包裹在单引号和双引号之间&#39;&quot;...&quot;&#39; 所以，环境变量包括： Production NODE_ENV = ‘production’, DEBUG_MODE = false, API_KEY = ‘…’ Development NODE_ENV = ‘development’, DEBUG_MODE = true, API_KEY = ‘…’ Testing NODE_ENV = ‘testing’, DEBUG_MODE = true, API_KEY = ‘…’ 我们可以看到，test环境继承开发环境， 开发环境继承生产环境 在你的代码中使用环境变量很容易： Vue.config.debug = process.env.DEBUG_MODE 10. 和后端框架的整合如果你编写的是一个纯静态的应用（不需要后端api），你可能不需要编辑config/index.js文件。然而，如果你想使用这个样板工程和现有的后端进行整合，你可以通过编辑config/index.js文件而直接产生前端资源到后端项目。 让我们看一下默认配置config/index.js: var path = require(&apos;path&apos;) module.exports = { build: { index: path.resolve(__dirname, &apos;dist/index.html&apos;), assetsRoot: path.resolve(__dirname, &apos;dist&apos;), assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, productionSourceMap: true }, dev: { port: 8080, proxyTable: {} } } 其中build部分包括以下选项： index 须是当前系统下的绝对路径 这个目录是存储生成的已经注入静态资源后的index.html文件 如果你的后端框架使用了模版，你可以相应的修改index.html，将这个路径指向后端程序要渲染的视图文件 assetsRoot 须是当前系统下的绝对路径 这个目录指向应用存放所有静态资源的路径 assetsSubDIrectiorywebpack产生的静态资源会存放于build.assetsRoot下的这个目录，这样，它们就不会和build.assetsRoot下的其他静态文件混合在一起。例如，如果build.assetsRoot是/path/to/dist，build.assetsSubDIrectiory是static，这样，所有的webpack处理的静态资源都会在path/to/dist/static下。 这个文件夹在每次执行build之前都会被清空，所以它应该只包含build过程产生的静态资源。 在static/下的文件在build的过程中会被直接复制到这个文件夹下。这意味着如果你改变了这个前提，其他所有的依赖于这个目录的绝对路径也要被修改。查看更多细节Handling Static Assets assetsPublicPathHTTP服务在assetsPublicPath 配置的路径下取得assetsRoot中的静态资源。在大部分情况，这个配置时跟目录/，当你的后端框架提供了带有前缀的静态资源路径时需要改动这个配置。在内部，这个配置会作为output.publicPath传递给webpack productionSourceMapbuild时是否产生资源文件的maps文件 port开发环境监听的端口号 proxyTable定义开发环境的代理规则，查看更多细节API Proxying During Development 11. 开发环境下API代理的配置当和已有的后端进行整合的时候，一个共同的需求就是在使用启动本地开发服务后调用后端借口。为了解决这个问题，我们可以配置config/index.js下的dev.proxyTable选项。这个开发服务使用了http-proxy-middleware作为代理。所以你可以查看它的文档，获得更细节的配置。这是一个简单的样例 // config/index.js module.exports = { // ... dev: { proxyTable: { // proxy all requests starting with /api to jsonplaceholder &apos;/api&apos;: { target: &apos;http://jsonplaceholder.typicode.com&apos;, changeOrigin: true, pathRewrite: { &apos;^/api&apos;: &apos;&apos; } } } } } 上述配置将请求/api/posts/1代理到http://jsonplaceholder.typicode.com/posts/1 单元测试， 端到端测试， SEO优化","tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"}]},{"title":"vuex使用笔记－－项目结构","date":"2017-02-08T09:20:28.000Z","path":"2017/02/08/veux-ont/","text":"概述Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation、和 getters 分割到单独的文件。 对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例： ├── index.html ├── main.js ├── api │ └── ... # 抽取出API请求 ├── components │ ├── App.vue │ └── ... └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 购物车实例index.jsimport Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; import * as actions from &apos;./actions&apos; import * as getters from &apos;./getters&apos; import cart from &apos;./modules/cart&apos; import products from &apos;./modules/products&apos; import createLogger from &apos;../../../src/plugins/logger&apos; Vue.use(Vuex) const debug = process.env.NODE_ENV !== &apos;production&apos; export default new Vuex.Store({ actions, getters, modules: { cart, products }, strict: debug, plugins: debug ? [createLogger()] : [] }) actions.jsimport * as types from &apos;./mutation-types&apos; export const addToCart = ({ commit }, product) =&gt; { if (product.inventory &gt; 0) { commit(types.ADD_TO_CART, { id: product.id }) } } getters.jsexport const cartProducts = state =&gt; { return state.cart.added.map(({ id, quantity }) =&gt; { const product = state.products.all.find(p =&gt; p.id === id) return { title: product.title, price: product.price, quantity } }) } modules/cart.jsimport shop from &apos;../../api/shop&apos; import * as types from &apos;../mutation-types&apos; // initial state // shape: [{ id, quantity }] const state = { added: [], checkoutStatus: null } // getters const getters = { checkoutStatus: state =&gt; state.checkoutStatus } // actions const actions = { checkout ({ commit, state }, products) { const savedCartItems = [...state.added] commit(types.CHECKOUT_REQUEST) shop.buyProducts( products, () =&gt; commit(types.CHECKOUT_SUCCESS), () =&gt; commit(types.CHECKOUT_FAILURE, { savedCartItems }) ) } } // mutations const mutations = { [types.ADD_TO_CART] (state, { id }) { state.lastCheckout = null const record = state.added.find(p =&gt; p.id === id) if (!record) { state.added.push({ id, quantity: 1 }) } else { record.quantity++ } }, [types.CHECKOUT_REQUEST] (state) { // clear cart state.added = [] state.checkoutStatus = null }, [types.CHECKOUT_SUCCESS] (state) { state.checkoutStatus = &apos;successful&apos; }, [types.CHECKOUT_FAILURE] (state, { savedCartItems }) { // rollback to the cart saved before sending the request state.added = savedCartItems state.checkoutStatus = &apos;failed&apos; } } export default { state, getters, actions, mutations } modules/products.jsimport shop from &apos;../../api/shop&apos; import * as types from &apos;../mutation-types&apos; // initial state const state = { all: [] } // getters const getters = { allProducts: state =&gt; state.all } // actions const actions = { getAllProducts ({ commit }) { shop.getProducts(products =&gt; { commit(types.RECEIVE_PRODUCTS, { products }) }) } } // mutations const mutations = { [types.RECEIVE_PRODUCTS] (state, { products }) { state.all = products }, [types.ADD_TO_CART] (state, { id }) { state.all.find(p =&gt; p.id === id).inventory-- } } export default { state, getters, actions, mutations }","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"BEM规则详解","date":"2017-02-08T09:19:30.000Z","path":"2017/02/08/BEM/","text":"特别声明：此篇文章由David根据csswizardry的英文文章原名《MindBEMding – getting your head ’round BEM syntax》进行翻译，整个译文带有我们自己的理解与思想，如果译得不好或不对之处还请同行朋友指点。如需转载此译文，需注明英文出处：http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax.以及作者相关信息 &emsp;&emsp;&emsp;——作者：csswizardry &emsp;&emsp;&emsp;——译者：David 人们问我最多的问题之一是在CSS类名中“–”和“__”是什么意思？它们的出现是源于BEM和Nicolas Gallagher… BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。 重要的是要注意，我使用的基于BEM的命名方式是经过Nicolas Gallagher修改过的。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。 命名约定的模式如下： .block{} .block__element{} .block--modifier{} .block 代表了更高级别的抽象或组件。 .block__element 代表.block的后代，用于形成一个完整的.block的整体。 .block–modifier代表.block的不同状态或不同版本。 之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定， .site-search{} /* 块 */ .site-search__field{} /* 元素 */ .site-search--full{} /* 修饰符 */ BEM的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素,还有一些是组件的其他形态或者是修饰符。我们用一个类比/模型来思考一下下面的这些元素是怎么关联的： .person{} .person__hand{} .person--female{} .person--female__hand{} .person__hand--left{} 顶级块是‘person’，它拥有一些元素，如‘hand’。一个人也会有其他形态，比如女性，这种形态进而也会拥有它自己的元素。下面我们把他们写成‘常规’CSS: .person{} .hand{} .female{} .female-hand{} .left-hand{} 这些‘常规’CSS都是有意义的，但是它们之间却有些脱节。就拿.female来说，是指女性人类还是某种雌性的动物？还有.hand，是在说一只钟表的指针（译注：英文中hand有指针的意思）？还是一只正在玩纸牌的手？使用BEM我们可以获得更多的描述和更加清晰的结构，单单通过我们代码中的命名就能知道元素之间的关联。BEM真是强大。 再来看一个之前用‘常规’方式命名的.site-search的例子： &lt;form class=&quot;site-search full&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;field&quot;&gt; &lt;input type=&quot;Submit&quot; value =&quot;Search&quot; class=&quot;button&quot;&gt; &lt;/form&gt; 这些CSS类名真是太不精确了，并不能告诉我们足够的信息。尽管我们可以用它们来完成工作，但它们确实非常含糊不清。用BEM记号法就会是下面这个样子： &lt;form class=&quot;site-search site-search--full&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;site-search__field&quot;&gt; &lt;input type=&quot;Submit&quot; value =&quot;Search&quot; class=&quot;site-search__button&quot;&gt; &lt;/form&gt; 我们能清晰地看到有个叫.site-search的块，他内部是一个叫.site-search__field的元素。并且.site-search还有另外一种形态叫.site-search–full。 我们再来举个例子…… 如果你熟悉OOCSS（面向对象CSS），那么你对media对象一定也不陌生。用BEM的方式，media对象就会是下面这个样子： .media{} .media__img{} .media__img--rev{} .media__body{} 从这种CSS的写法上我们就已经知道.mediaimg 和.mediabody一定是位于.media内部的，而且.mediaimg–rev是.mediaimg的另一种形态。仅仅通过CSS选择器的名字我们就能获取到以上全部信息。 BEM的另外一个好处是针对下面这种情况： &lt;div class=&quot;media&quot;&gt; &lt;img src=&quot;logo.png&quot; alt=&quot;Foo Corp logo&quot; class=&quot;img-rev&quot;&gt; &lt;div class=&quot;body&quot;&gt; &lt;h3 class=&quot;alpha&quot;&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=&quot;lede&quot;&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 光从上面的代码来看，我们根本不明白.media和.alpha两个class彼此之间是如何相互关联的？同样我们也无从知晓.body和.lede之间，或者.img-rev 和.media之间各是什么关系？从这段HTML（除非你对那个media对象非常了解）中我们也不知道这个组件是由什么组成的和它还有什么其他的形态。如果我们用BEM方式重写这段代码： &lt;div class=&quot;media&quot;&gt; &lt;img src=&quot;logo.png&quot; alt=&quot;Foo Corp logo&quot; class=&quot;media__img--rev&quot;&gt; &lt;div class=&quot;media__body&quot;&gt; &lt;h3 class=&quot;alpha&quot;&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=&quot;lede&quot;&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 我们立马就能明白.media是一个块，.mediaimg–rev是一个加了修饰符的.mediaimg的变体，它是属于.media的元素。而.media__body是一个尚未被改变过的也是属于.media的元素。所有以上这些信息都通过它们的class名称就能明白，由此看来BEM确实非常实用。 丑极了!通常人们会认为BEM这种写法难看。我敢说，如果你仅仅是因为这种代码看上去不怎么好看而羞于使用它，那么你将错失最重要的东西。除非使用BEM让代码增加了不必要的维护困难，或者这么做确实让代码更难读了，那么你在使用它之前就要三思而行了。但是，如果只是“看起来有点怪”而事实上是一种有效的手段，那么我们在开发之前当然应该充分考虑它。 是，BEM看上去确实怪怪的，但是它的好处远远超过它外观上的那点瑕疵。 BEM可能看上去有点滑稽，而且有可能导致我们输入更长的文本（大部分编辑器都有自动补全功能，而且gzip压缩将会让我们消除对文件体积的担忧），但是它依旧强大。 用还是不用BEM我在我的所有项目中都使用了BEM记号法，因为它的有效性已经被它自己一次又一次地证明。我也极力地建议别人使用BEM，因为它让所有东西之间的联系变得更加紧密，让团队甚至是你个人都能够更加容易地维护代码。 然而，当你真正使用BEM的时候，重要的是，请记住你没必要真的在每个地方都用上它。比如： .caps{ text-transform:uppercase; } 这条CSS不属于任何一个BEM范畴，它仅仅只是一条单独的样式。 另一个没有使用BEM的例子是： .site-logo{} 这是一个logo，我们可以把它写成BEM格式，像下面这样： .header{} .header__logo{} 但我们没必要这么做。使用BEM的诀窍是，你要知道什么时候哪些东西是应该写成BEM格式的。因为某些东西确实是位于一个块的内部，但这并不意味它就是BEM中所说的元素。这个例子中，网站logo完全是恰巧在.header的内部，它也有可能在侧边栏或是页脚里面。一个元素的范围可能开始于任何上下文，因此你要确定只在你需要用到BEM的地方你才使用它。再看一个例子： &lt;div class=&quot;content&quot;&gt; &lt;h1 class=&quot;content__headline&quot;&gt;Lorem ipsum dolor...&lt;/h1&gt; &lt;/div&gt; 在这个例子里，我们也许仅仅只需要另一个class，可以叫它.headline；它的样式取决于它是如何被层叠的，因为它在.content的内部；或者它只是恰巧在.content的内部。如果它是后者（即恰巧在.content的内部，而不总是在）我们就不需要使用BEM。 然而，一切都有可能潜在地用到BEM。我们再来看一下.site-logo的例子，想象一下我们想要给网站增加一点圣诞节的气氛，所以我们想有一个圣诞版的logo。于是我们有了下面的代码： .site-logo{} .site-logo--xmas{} 我们可以通过使用–修饰符来快速地为我们的代码构建另一个版本。 BEM最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。随着接触的多了，有了经验积累，你慢慢就会知道怎么用，这些问题也不再是问题。 结束语所以，BEM（或BEM的变体）是一个非常有用，强大，简单的命名约定，以至于让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确而且更加严密。 尽管BEM看上去多少有点奇怪，但是无论什么项目，它对前端开发者都是一个巨有价值的工具。 扩展阅读 Yandex BEM/OOCSS Template Components BEM: The Block, Element, Modifier Approach To Decoupling HTML And CSS CSS methodology and frameworks Maintainable CSS with BEM A New Front-End Methodology: BEM What is BEM? Rubbing Noses With inuit.css SMACSS: Notes On Usage The History of BEM Start developing BEM with project-stub 译者手语：整个翻译依照原文线路进行，并在翻译过程略加了个人对技术的理解。如果翻译有不对之处，还烦请同行朋友指点。谢谢！ 关于David2009年开始接触前端开发，2011年组建创业团队——[五维互动]，2012年团队被“收编”并更名[创影互动]，遂只身来上海发展，现在就职于FlipScript。欢迎交流共勉：腾讯微博、个人博客。 如需转载烦请注明出处： 英文原文：http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/ 中文译文：http://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html 著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。原文: http://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html © w3cplus.com","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"BEM","slug":"BEM","permalink":"http://yoursite.com/tags/BEM/"}]}]